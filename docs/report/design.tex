\documentclass[JDala.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}
	
\subsection{Motivational Example 1 - Immutability}	


Consider the following code in Listing~\ref{listing:sort}~\footnote{TODO: add reference to full code in anonymised repo}.

\begin{lstlisting}[language=Java, caption=Erroneous Attempt to Make a Sorted List Immutable, label=listing:sort]
List<Person> people =  .. ;
Collections.sort(people,
   Comparator.comparing(Person::getName));
Collections.unmodifiableList(people);
for (Person p:people)  System.out.println(p);
\end{lstlisting}

This is an attempt to create an unmodifiable sorted list of \texttt{Person} instances. 
However, while \texttt{Collections::unmodifiableList} make the list immutable, the objects within the list can still be mutated, including changes to the name property used as sort key.  Once such a mutation 
has taking place, it is no longer guaranteed that the members of the list are sorted by name, and an application that incorrectly relies on the assumption that sorting is in place will encounter unexpected behaviour.

In \jdala ,  this can be prevented by declaring the respective list as immutable. Since objects cannot be directly annotated in Java, a local variable pointing to the respective object is annotated instead.  This is shown in Listing~\ref{listing:sort-with-jdala}. 

\begin{lstlisting}[language=Java, caption=Make a Sorted List Immutable with \jdala, label=listing:sort-with-jdala]
List<Person> people =  .. ;
Collections.sort(people,
   Comparator.comparing(Person::getName));
@Immutable people2=people;
..
\end{lstlisting}

Once a variable is annotated, \jdala will mark the object it points to as immutable, and will prevent any further modifications of this object. 
In particular, calls of \texttt{Person::setName} (writing the field \texttt{Person::name}) will result in a runtime exception. 
This is \textit{fail-fast behaviour}~\cite{shore2004fail}, i.e. unexpected behaviour is avoided by creating an informative error signal at the point the issue is caused. 
 
\subsection{Motivational Example 2 - Deadlock Prevention}	

Consider Listing~\ref{listing:deadlock}.  This is a simple method to transfer money between two accounts. To ensure that there are sufficient funds available, the respective accounts are locked using the  synchronized keywords.  However, if an application encounters a situation where money has to be transferred within a shorty time distance between two accounts in both directions, a deadlock is created and the application stalls.

\begin{lstlisting}[language=Java, caption=Money transfer implementation prone to deadlock, label=listing:deadlock]
void transfer(Account from, Account to, double amount) {
	synchronized (from) {
		from.withdraw(amount);
		Thread.sleep(1_000); // to simulate DB workload
		synchronized (to) to.deposit(amount);
}}
.. 
ThreadPoolExecutor tpool = .. ;
@Isolated Account acc1,acc2  ..;
Future f1 = tpool.submit(() -> transfer(acc1, acc2, 50)); 
Future f2 = tpool.submit(() -> transfer(acc2, acc1, 80));
\end{lstlisting}

Without \jdala, executing this program results in a deadlock.  However, running this program with the \jdala agent and annotating the accounts with \Isolated , this cab be prevented. The program immediately fails with a \jdala exception indicating (wrapped in the \texttt{ExecutionException} referenced by the futures) indicating that the account instances are associated with the main thread, but accessed from another (threadpool thread). 

\subsection{Capabilities as Annotations}

In \jdala, the \dala capabilites are represented using three dedicated annotation types \Immutable, \Isolated and \Local.  Global data structures (maps that are static members of the class \texttt{JDala}) are used to track objects with the respective capabilities.   

Since objects cannot directly be annotated, the association with capabilities is achieved by annotating local variables pointing to objects.  This is illustrated in Listing~\ref{listing:annotation}.  In line 1, the newly created \texttt{List} instance is marked as immutable.  A second list created in line 2 is not marked as immutable at the allocation site, but later. This is achieved by an assignment to the annotated variable \texttt{list3}. 


\begin{lstlisting}[language=Java, caption=Associating objects with capabilities, label=listing:annotation]
@Immutable List list = new ArrayList();
List list2 = new ArrayList();
@Immutable List list3 = list2;
\end{lstlisting}


\subsection{Enforcing the Semantics of Capabilities}

The semantics of the respective capabilities in implemented using instrumention. For this purpose, \jdala builds an agent. The instrumentation controls the heap of an instrumented application by maintaining safe objects~\footnote{\textit{Safe} objects are objects annotated using either \Immutable, \Isolated or \Local, all other objects are referred to as \textit{unsafe} objects.} in global data structures, and intercepting bytecode instructions reading and writing fields. 








	


\subsection{Annotation definitions}

\subsection{Object Biased Definitions}

\subsection{signaling violations with runtime exceptions}

\subsection{global data structures to track annotated objects}

\subsection{memory issues}

\subsection{Dealing with Reflection}
(Field::set)

\subsection{Static Fields}

\subsection{modelling transfer}


\end{document}