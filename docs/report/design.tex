\section{The Design of \jdala}
\label{sec:design}	


\subsection{Capabilities as Annotations}
\label{subsection:capabilitesAsAnnotations}

In \jdala, the \dala capabilites are represented using three dedicated annotation types \Immutable, \Isolated and \Local.  Global data structures (maps that are static members of the class \texttt{JDala}) are used to track objects with the respective capabilities.   

Since objects cannot be annotated directly, the association between objects and object capabilities is achieved by annotating local variables pointing to objects.  This is illustrated in Listing~\ref{listing:annotation}.  In line 1, the newly created \texttt{List} instance is marked as immutable.  A second list created in line 2 is not marked as immutable at the allocation site, but later. This is achieved by an assignment to the annotated variable \texttt{list3}. 


\begin{lstlisting}[language=Java, caption=Associating objects with capabilities, label=listing:annotation]
@Immutable List list = new ArrayList();
List list2 = new ArrayList();
@Immutable List list3 = list2;
\end{lstlisting}


\subsection{Enforcing the Semantics of Capabilities}

The semantics of the respective capabilities in implemented using instrumentation injecting code to enforce the respective capabilities. 
\jdala uses ASM~\cite{bruneton2002asm} for this purpose.
For this purpose, \jdala builds an agent. The instrumentation controls the heap of an instrumented application by maintaining safe objects~\footnote{\textit{Safe} objects are objects annotated using either \Immutable, \Isolated or \Local, all other objects are referred to as \textit{unsafe} objects.} in global data structures, and intercepting and checking bytecode instructions reading and writing fields.  Instructions for fields with a reference type, special instructions for fields with one of the various Java primitive types, and instructions to access array slots are all instrumented. 

The injected code broadly falls into two categories: registration and enforcement. When  annotated references to objects are encountered, the respective objects are registered as immutable, local or isolated in static maps maintained by the \texttt{JDala} class. In case of immutability, referenced objects are registered as immutable as well. For this purpose, a simple reflection-based  heap traversal of the object to be registered as immutable is performed.  If already registered objects are reregistered with a weaker capability~\footnote{The capabilities considered here form a hierarchy, see \cite{Dala_Paper} for details}, a \texttt{DalaRestrictionException} is raised.  This functionality is implemented in various \texttt{JDala:register*} methods.

When fields of registered objects are accessed, the injected code invokes check methods \texttt{JDala:check*} to enforce the capability contract. Violations are signalled by raising a \texttt{DalaCapabilityViolationException} exception.


\todo[inline] {I think we have space to insert a test here}


\subsection{Object \& Class Biased Definitions}


\jdala provides two mechanisms for defining capabilities. The primary method uses the variable level annotations discussed in Section~\ref{subsection:capabilitesAsAnnotations}. This method assigns a capability to an object when a variable pointing to it is annotated. Any future reassignment into that local variable must reassert a capability\todo{Jens: what does reassert mean ??} or be considered unsafe.
Once an object has been assigned a capability, it maintains that capability—or a stricter one—for its entire lifetime.

A secondary mechanism applies only to \Immutable capabilities and involves defining immutable classes globally. Classes listed in \texttt{resources/immutable-classes.txt} are automatically treated as immutable. This approach is suitable for Java classes that are intrinsically immutable, such as \texttt{String}, \texttt{Boolean}, \texttt{Integer}, and \texttt{Byte}. Note that all primitive types are treated as \texttt{@Immutable} by default.

\todo[inline]{J $>$ Q: remind me why we did this ? I.e. we are not intercepting field writes here, or is there a use case for this? E.g. would we intercept using reflection to access the int wrapper by an Integer ?}



\subsection{Object Initialisation Protocol}

\todo[inline]{J $>$ Q: can you please add a short paragraph here ? We do have space for a short code listing. }

% Jens: I moved this up
%\subsection{Signalling Violations}
%
%Violations of \dala constraints are indicated via runtime exceptions. The two exception types are used:
%
%\subsubsection{\texttt{DalaCapabilityViolationException}}
%This exception is thrown when a runtime violation of a capability contract is detected. Examples include mutating an \Immutable object, accessing an \Isolated object from a non-owning thread, or using an \Local object in a different thread.
%
%\subsubsection{\texttt{DalaRestrictionException}}
%This exception is raised when capability hierarchies are breached. For instance, transitioning an object from \Immutable to \Isolated, or storing an \textit{unsafe} object within a \Local object, triggers this violation. The exception ensures adherence to the \dala capability hierarchy.
%
%\subsection{Global data structures to track annotated objects}
%\label{subsection:globalDataStructures}
%Capability tracking is centralized via global data structures stored in the \jdala class. This is apposed to storing the annotation data locally with each object. 


\subsection{Static Fields}
Static fields are shared across all instances of a class and are thus considered class-level, rather than object-level. Modifications to static fields are not captured by \jdala object instrumentation. 
%As such, developers must take extra care when working with static data in the context of \dala capabilities.

\subsection{Memory Leak Prevention}

A key implication of using global data structures for capability tracking is the potential for memory leaks. Because references are maintained in maps referenced through static variables, those objects may not be eligible for garbage collection. To mitigate this, weak references are employed within these collections, allowing unused objects to be reclaimed by the JVM's garbage collector when no strong references remain.


\subsection{Reflection Support}

Java reflection can be used to bypass conventional field access patterns, posing a challenge to capability enforcement. To address this, \jdala instruments the \texttt{Field::get} and \texttt{Field::set} methods. This ensures that field modifications performed via reflection still trigger the appropriate capability checks.

There are other dynamic programming pattern that could be used to bypass the capability contracts. In particular, \jdala does currently  not restrict the use of \texttt{Unsafe}~\cite{mastrangelo2015use}. However, the direct use of \texttt{Unsafe} by applications is discouraged and prevented in newer versions of Java.



\subsection{Modelling the Transfer of \Isolated objects}

\dala allows for isolated objects to be transferred between threads.
For moving isolated objects between threads \dala outlines the use of a consume method that only ever allows one reference to an Object. 
Any isolated object that moves from one thread to another will lose its affiliation with the first thread. This principle could be recreated in Java by setting a reference to \texttt{null} after an object has moved. This could lead to a nondescriptive NullPointerException later in the code.

For \Isolated objects \jdala allows multiple references to exist in one thread, with checks being performed that the object is in the thread it is supposed to be in. \Isolated objects are initially associated with the thread they were created in. For transferring an \Isolated object to a new thread a dedicated \textit{portal object} is used. Portal object protocols have to be defined by specifying methods for objects to enter a portal (therefore being disconnected from the current thread) and methods to exit a portal (therefore becoming associated with the current thread).  While it is possible to define portal objects by annotating objects, with properties to define the respective enter and exit methods, we deemed this  as too complex. Most transfers follow patterns where portal objects are instances of dedicated \textit{portal classes} like blocking queues.  
Those classes are defined in the resource \texttt{portal-classes.json}, the classical example is\texttt{ java.util.concurrent.BlockingQueue} with \texttt{put/\-offer/\-add} entry  and \texttt{poll/\-take/\-remove} exit methods. Defining a particular type as portal also applies to its subtypes. 


If an isolated object enters a portal it goes into a \textit{transfer state}. In this state the object can't be accessed by any thread. The object can then leave the portal via one of the predefined exit methods and at this point leaves the transfer state and is owned by the tread invoking the exit method.

\todo[inline]{J $>$ Q: we should clarify what accessed means here -- I think thsi translates
to "its fields can neither be read nor mutated". Perhaps add a footnote}




%\subsection{Java Bytecode Instrumentation}
%\jdala employs the ASM framework to instrument Java bytecode at runtime. This allows interception of field and array access operations at the bytecode level. Specifically, instructions like \texttt{getField}, \texttt{putField}, and array access opcodes are intercepted and augmented with capability checks.
