\documentclass[../JDala.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}
	
\subsection{Motivational Example 1 - Immutability}	


Consider the following code in Listing~\ref{listing:sort}~\footnote{TODO: add reference to full code in anonymised repo}.

\begin{lstlisting}[language=Java, caption=Erroneous Attempt to Make a Sorted List Immutable, label=listing:sort]
List<Person> people =  .. ;
Collections.sort(people,
   Comparator.comparing(Person::getName));
Collections.unmodifiableList(people);
for (Person p:people)  System.out.println(p);
\end{lstlisting}

This is an attempt to create an unmodifiable sorted list of \texttt{Person} instances. 
However, while \texttt{Collections::unmodifiableList} make the list immutable, the objects within the list can still be mutated, including changes to the name property used as sort key.  Once such a mutation 
has taking place, it is no longer guaranteed that the members of the list are sorted by name, and an application that incorrectly relies on the assumption that sorting is in place will encounter unexpected behaviour.

In \jdala ,  this can be prevented by declaring the respective list as immutable. Since objects cannot be directly annotated in Java, a local variable pointing to the respective object is annotated instead.  This is shown in Listing~\ref{listing:sort-with-jdala}. 

\begin{lstlisting}[language=Java, caption=Make a Sorted List Immutable with \jdala, label=listing:sort-with-jdala]
List<Person> people =  .. ;
Collections.sort(people,
   Comparator.comparing(Person::getName));
@Immutable people2=people;
..
\end{lstlisting}

Once a variable is annotated, \jdala will mark the object it points to as immutable, and will prevent any further modifications of this object. 
In particular, calls of \texttt{Person::setName} (writing the field \texttt{Person::name}) will result in a runtime exception. 
This is \textit{fail-fast behaviour}~\cite{shore2004fail}, i.e. unexpected behaviour is avoided by creating an informative error signal at the point the issue is caused. 
 
\subsection{Motivational Example 2 - Deadlock Prevention}	

Consider Listing~\ref{listing:deadlock}.  This is a simple method to transfer ,money between two accounts. To ensure that there are sufficient funds available, the respective accounts are locked using the  synchronized keywords.  However, if an application encounters a situation where money has to be transferred within a shorty time distance between two accounts in both directions, a deadlock is created and the application stalls.

\begin{lstlisting}[language=Java, caption=Money transfer implementation prone to deadlock, label=listing:deadlock]
void transfer(Account from, Account to, double amount) {
	synchronized (from) {
		from.withdraw(amount);
		Thread.sleep(1_000); // to simulate DB workload
		synchronized (to) to.deposit(amount);
}}
\end{lstlisting}



	
\subsection{Java agents general intro}

\subsection{Annotation definitions}

Annotations

\subsection{Object Biased Definitions}

\subsection{signaling violations with runtime exceptions}

\subsection{global data structures to track annotated objects}

\subsection{memory issues}

\subsection{Dealing with Reflection}
(Field::set)

\subsection{Static Fields}

\subsection{modelling transfer}


\end{document}